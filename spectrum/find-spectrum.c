#include <stdlib.h>
#include <stdio.h>

#include "find-spectrum.h"

/* Auxiliary routine: printing a matrix */
void print_matrix( char* desc, int m, int n, fcomplex* a, int lda ) {
    int i, j;
    printf( "\n%s\n", desc );
    for( i = 0; i < m; i++ ) {
        for( j = 0; j < n; j++ )
            printf( " (%6.2f,%6.2f)", a[i+j*lda].re, a[i+j*lda].im );
        printf( "\n" );
    }
}

/* Auxiliary routine: printing a real matrix */
void print_rmatrix( char* desc, int m, int n, float* a, int lda ) {
    int i, j;
    printf( "\n%s\n", desc );
    for ( i = 0; i < m; i++ ) {
        for ( j = 0; j < n; j++ ) printf( " %11.9f", a[i+j*lda] );
        printf( "\n" );
    }
}

/*  Print eigenvalues in the range [first, last]
 * 
 * All eigenvalues are stored in the first row of the matrix `w` i.e. 
 * in order to print eigenvalues one has to print only the first row 
 * of the matrix `w`.
 * 
 * first - the first column to be printed (first = 0 will start with printing
 * the ground state energy)
 * last - the last eigenvalue to be printed (last = 1, only the ground state
 * energy is be printed)
 */
void print_eigenvalues( int first, int last, float* a ) 
{
    int i = first;
    for ( ; i < last; i++ ) printf( " %11.9f", a[i] );
    printf( "\n" ); 
}



/* Print eigenvectors in a compact way i.e. there are printed only those 
 * basis vectors which have the most prominent amplitudes  in the state.
 * 
 * Print only the first `m` eigenvectors.
 * 
 * input:
 * a - matrix with the diagonalisation result
 * n - basis size
 * last - the last eigenstate you want to be printed 
 *         (eigenstates are orderd with respect to their eigenvalues, in an 
 *         ascending order i.e. 0th eigenvector has the smallest eigenvalue)
 * b - descriptor of the basis which was used in the computations 
 */
void sort_print_lower_spectrum(fcomplex* a, int n, basis b, int last, 
                                fcomplex* work, int* work_int)
{ 
    printf("\n# Ground state and the lowest excitations:\n");
    // if the desired number of eigenvectors, `m`, is larger than
    // the their total number, `n`, then print all `n` eigenvectors.
    int bound = (last<n) ? last : n ;
    for (int k=0; k < bound; k++)
        sort_print_eigenvector_summary( a, work, work_int, n, b, k);
}

/* Print eigenvectors in a compact way i.e. there are printed only those 
 * basis vectors which have the most prominent amplitudes  in the state.
 * 
 * Prints only the statat numbers between `first` and `last` 
 * 
 * This function is used in order to reach to the excitation of the rotational
 * degrees of freedom ($j>0$), and skipp the ladder of states generated by the
 * harmonic oscillator modes.
 * 
 * input:
 * a - matrix with the diagonalisation result
 * n - basis size
 * first - number of the last eigenstate you want to be printed 
 * last - number of the last eigenstate you want to be printed 
 *         (eigenstates are orderd with respect to their eigenvalues, in an 
 *         ascending order i.e. 0th eigenvector has the smallest eigenvalue)
 * b - descriptor of the basis which was used in the computations 
 */
void sort_print_upper_spectrum(fcomplex* a, int n, basis b, int first, 
                            int last, fcomplex* work, int* work_int)
{ 
    printf("\n# Excited states :\n");
    // sanity check
    if (first < 1 || last < 1 || last < first)
    {
        printf("# incorrect input first = %d, last = %d.\n", first, last);
        return;
    }
    // if the number of the `first` eigenvector, is larger than
    // the their total number, `n`, then inform about it and exit
    if (first > n)
    {
        printf("# The first of the requested states (%d) is beyond ", first);
        printf("the total number of states (%d)", n);
        return;
    }
    // if the number of the last requested eigenvector, `last`, is larger than
    // the total number of eigenvectors, `n`, then up to the `n`th eigenvector.
    int bound = (last<n) ? last : n ;
    // the first eigenstate (ground state) has No 0 on a list of eigenvectors
    int i = first-1; 
    for (; i < bound; i++)
        sort_print_eigenvector_summary( a, work, work_int, n, b, i);
}

void sort_print_eigenvector_summary( fcomplex* a, fcomplex* work, 
                                    int* work_int, int n, basis b, int m )
{
    // Preselection, the vectors which are of no importance will be neglected;
    const float lower_limit = 1.0e-12f;
    int i, length=0;
    fcomplex amp;
    float abs_amp2;
    for ( i = 0; i < n; i++ )
    {
        amp = a[ m*n + i ];
        abs_amp2 = fcomplex_amplitude_sqr( &amp );
        if (abs_amp2 > lower_limit) 
        {
            work[length].re = amp.re;
            work[length].im = amp.im;
            work_int[length] = i;
            length++;
        }
    }

    // sorting
    sort_fcomplex(work, work_int, length);

    // printing
    printf( " |%5d> = ", m );
    versor ket;
    for ( i = 0; i < length; i++ )
    {
        if(i!=0)
            printf("           ");
        amp = work[i];
        printf( "(%10.7f,%10.7f)", amp.re, amp.im );
        ket =  get_versor_from_index( work_int[i], b );
        show_versor( ket );
        printf( " +\n" );
    }
    printf( "            ...\n" );
}

void sort_fcomplex(fcomplex* data, int* indices, int length)
{
    int sorted = 0;
    int i;
    float amp0;
    float amp1;
    fcomplex temp_fc;
    int temp_int;
    while ( !sorted ) 
    {
        sorted = 1;
        amp0  =  fcomplex_amplitude_sqr( data );
        for (i=1; i<length; i++)
        {
            // amp0 is the amplitude of data[i-1]
            // amp1 is the amplitude of data[i]
            amp1 = fcomplex_amplitude_sqr( data+i );
            if (amp1 > amp0)
            {
                // swap data
                temp_fc = data[i];
                data[i] = data[i-1]; 
                data[i-1] = temp_fc;
                // swap int
                temp_int = indices[i];
                indices[i] = indices[i-1];
                indices[i-1] = temp_int;
                // raise the flag
                sorted = 0;
                // prepare amp0 for the next run of the loop
                // amp0 = amp0;
            }
            else
            {
                // prepare amp0 to compare it with 
                // the next element on the list
                amp0 = amp1;
            }
        }
    }
}
